#!/usr/bin/perl
# POD {{{
=head1 NAME

tb - Manage projects by throwing them into and out of Tarballs

=head1 SYNOPSIS

	tb [options] <projects> 

=head1 OPTIONS

=over 8

=item B<--dryrun>

=item B<-n>

Do not actually run any system commands. Just output what WOULD run.

=item B<--delete>

=item B<-d>

Delete a project from the active folder after tarballing.

=item B<--list>

=item B<-l>

List all known active projects and tarballs.

=item B<--force>

=item B<-f>

Force a recovery action to overrite any existing files if any are found.

=item B<--recover>

=item B<--reverse>

=item B<-r>

Reverse the backup process so the backup is restored over the active version.
If an active version of a project already exists this function will not continue unless force (-f) is specified.

=item B<-v>

=item B<--verbose>

Be more verbose when outputting information to STDERR.
Specify multiple times to increase verbosity.

=back

=head1 DESCRIPTION

A command line tool for the manipulation of projects.

=head1 EXAMPLES

=over

=item B<tb foo>

Tarball the project 'foo' to backup.

=item B<tb -d foo>

Tarball the project 'foo' to backup and delete the original active folder afterwards.

=item B<tb -r foo>

Recover the tarballed project 'foo' from backup into an active project folder.
If 'foo' already exists it will NOT be overwritten.

=item B<tb -rf foo>

Same as above but this time if 'foo' does exist it will be removed before the restore takes place.

=item B<tb -l>

List all known projects (both tarballs and active)

=back

=head1 BUGS

Quite probably.

Please report to the author when found.

=head1 AUTHOR

Matt Carter <m@ttcarter.com>

=cut
# }}} POD

package tb;
our $VERSION = '0.1.0';

# Header {{{
use IO::Handle;
use Getopt::Long;
Getopt::Long::Configure('bundling', 'ignorecase_always', 'pass_through');
STDERR->autoflush(1); # } Flush the output DIRECTLY to the output buffer without caching
STDOUT->autoflush(1); # }

use Data::Dump; # FIXME: Debugging modules
# }}} Header

# Functions {{{
# Flow control {{{
sub fatal {
	# Print an error message and fatally die
	print STDERR @_, "\n";
	exit 1;
}

sub say {
	# Print a message to STDERR based on the verbosity level
	our $verbose;
	my $verbosity = shift;
	print STDERR @_, "\n" if ($verbose >= $verbosity);
}

sub pause {
	# Wait a number of seconds (specified by the -w [seconds]) between VM operations
	# This function purposely ignores the first vm (thus not bothering to wait for the last vm to finish)
	our $wait;
	if ($wait > 0) {
		say(0, "Waiting $wait seconds...");
		sleep($wait);
	}
}

sub error {
	my $action = shift;
	my $subject = shift;
	if (ref($@) eq 'SoapFault') {
		say(0, "ERROR: " . $@->detail);
	} else {
		say(0, "ERROR: General fault!");
	}
	fatal("Stopping execution. Use -f to force continue.") unless $force;
}
# }}} Flow control

sub run {
	our $dryrun;
	my $cmd = shift;
	if ($dryrun) {
		say 0, "Would run command: [$cmd]";
		return 1;
	} else {
		$return = system $cmd;
		return $return == 0 ? true : false;
	}
}

# }}} Functions

# Command line options loading {{{
my $delete, $recover, $list;
my $path_projects, $path_tarballs;
our $dryrun;
our $verbose = 0;
GetOptions(
	'list|l' => \$list,
	'dryrun|n' => \$dryrun,
	'verbose|v+' => \$verbose,
	'delete|d' => \$delete,
	'recover|reverse|r' => \$recover,
	'force|f' => \$force,
	'path-projects=s' => \$path_projects,
	'path-tarballs=s' => \$path_tarballs,
);

my $projects;
my $tarballs;
if ($path_projects) {
	$projects = $path_projects;
} elsif ($ENV{TBPROJECTS}) {
	$projects = $ENV{TBPROJECTS};
} else {
	fatal "No project path specified. Use either --path-projects or set the environment variable TBPROJECTS";
}

if ($path_tarballs) {
	$tarballs = $path_tarballs;
} elsif ($ENV{TBTARBALLS}) {
	$tarballs = $ENV{TBTARBALLS};
} else {
	fatal "No tarball path specified. Use either --path-tarballs or set the environment variable TBTARBALLS";
}

say 2, "Using Projects path [$projects]";
say 2, "Using Tarball path [$tarballs]";
# }}} Command line options loading

chdir($projects) or fatal "Cannot change to projects root directory '$projects'";
fatal "Cannot find tarball root directory '$tarballs'" unless -d $tarballs;

if ($list) {
	my $count_active = 0;
	my $count_tarballs = 0;
	my $count_both = 0;
	my $last;
	for my $project (sort map { s!^(.*)/(.*?)(\.tar\.bz2)?$!\2!; $_ } (glob("$projects/*"), glob("$tarballs/*.bz2"))) { # Return all files in both folders, clip out the directory + suffix, sort
		next if $project eq $last;
		$last = $project;
		my $hasall = 0;
		$out = '';
		if (-d "$projects/$project") {
			$out .=  '[A]';
			$count_active++;
			$hasall = 1;
		} else {
			$out .= '   ';
		}
		$out .= ' ';
		if (-f "$tarballs/$project.tar.bz2") {
			$out .= '[T]';
			$count_tarballs++;
			$count_both++ if $hasall = 1;
		} else {
			$out .= '   ';
		}
		$out .= " $project";
		say 0, $out;
	}

	say;
	say 0, "[A]ctive = $count_active, [T]arballs = $count_tarballs, Both = $count_both";
	exit;
}

for my $project (@ARGV) {
	$project =~ s/\/$//; # Chop off backslash if any
	my $tarball = "$tarballs/$project.tar.bz2";
	say 1, "Operating on project '$project'";

	if ($recover) {
		fatal "Tarball '$tarball' not found when trying to recover project '$project'. Aborting" unless (-f $tarball);
		if (-d $project) { # Project folder exists
			if ($force) { # Permission to nuke it?
				run "rm -rf '$project'" or fatal "Cannot remove existing project folder '$project' to restore Tarball";
			} else {
				fatal "Project '$project' already exists when recovering project from Tarball. Use '-f' to force deletion of existing project.";
			}
		}
		run "mkdir '$project'" or fatal "Failed to create directory when recovering project '$project'";
		run "tar xvfj $tarball" or fatal "Failed to extract from Tarball when recovering project '$project'";
	} else { # Do a normal push to tarball
		fatal "Project '$project' not found. Aborting" unless (-d $project);
		run "rm '$tarball'" or fatal "Failed to remove existing tarball - '$tarball'" if (-f $tarball);
		run "tar cvfj $tarball $project" or fatal "Failed to tarball project '$project'";
		run "rm -rf $project" or fatal "Failed to erased project tree for project '$project'" if $delete;
	}
}
